<html>
<head>
<title>Effective Scala</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<script type="text/javascript" src="http://use.typekit.com/bub8efs.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>

<!--
<link href='http://fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Droid+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
-->

<link href='http://fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>

<style>	
	body {
		font-family: times, serif;
		margin: 0 1.0in 0 1.0in;
/*		line-height: 1.3em;*/
	}

	address {
		text-align: center;
	}
	
	.header {
		text-align: center;
		margin-top: 1em;
	}
	
	.rhs {
		text-align: left;
	}
	
	p {
		text-indent: 1em;
		text-align: justify;
	}
	
	.LP {
		text-indent: 0em;
	}
	
	code {
		font-family: "Droid Sans Mono'", monospace;
/*		font-size: 0.75em;*/
		font-size: 0.80em;
	}
	
	address {
		font-family: sans-serif;
	}
	
	h1 {
		font-family: sans-serif;
	}
	
	h2 {
		font-weight: bold;
		font-size: 110%;
		margin-top: 1.5em;
		margin-bottom: 0.05in;
	}
	
	h3 {
		font-size: 100%;
		font-style: oblique;
		margin-top: 1.5em;
		margin-bottom: 0.05in;
	}
	
	pre {
		margin: 0 0.5in 0 0.5in;
	}
	
	dl.rules dt {
		font-style: oblique;
	}
	
	table#toc {
		margin: 0 auto;
	}
	
	/* XXX: apply only to TOC. todo: reapply -- html whatever? */   
	ul {
	/*	list-style-type: none;*/
	}
	
	.algo {
		font-variant: small-caps;
	}
	
	div.explainer {
		margin-left: 3em;
		border-left: 2px solid;
		padding-left: 1em;
	}
	
	.explainer > h3 {
		margin-top: 0px;
		font-style: normal;
	}
	
	.footer {
		font-style: oblique;
		font-size: small;
	}
</style>
</head>

<body>
<p><a href="http://github.com/twitter/effectivescala"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://a248.e.akamai.net/assets.github.com/img/edc6dae7a1079163caf7f17c60495bbb6d027c93/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub"></a></p>

<h1 class="header">Effective Scala</h1>

<address>Marius Eriksen, Twitter Inc.<br />marius@twitter.com (<a href="http://twitter.com/marius">@marius</a>)<br /><br />[translated by Yuta Okamoto (<a href="http://twitter.com/okapies">@okapies</a>)]</address>

<h2>Table of Contents</h2>

<ul>
<li><strong><a href="#序章">序章</a></strong></li>
<li><strong><a href="#整形">整形</a></strong>: <em><a href="#整形-ホワイトスペース">ホワイトスペース</a></em>, <em><a href="#整形-命名">命名</a></em>, <em><a href="#整形-インポート">インポート</a></em>, <em><a href="#整形-中カッコ">中カッコ</a></em>, <em><a href="#整形-パターンマッチ">パターンマッチ</a></em>, <em><a href="#整形-コメント">コメント</a></em></li>
<li><strong><a href="#型とジェネリクス">型とジェネリクス</a></strong>: <em><a href="#型とジェネリクス-戻り型アノテーション">戻り型アノテーション</a></em>, <em><a href="#型とジェネリクス-変位">変位</a></em>, <em><a href="#型とジェネリクス-型エイリアス">型エイリアス</a></em>, <em><a href="#型とジェネリクス-暗黙">暗黙</a></em></li>
<li><strong><a href="#コレクション">コレクション</a></strong>: <em><a href="#コレクション-階層">階層</a></em>, <em><a href="#コレクション-利用">利用</a></em>, <em><a href="#コレクション-スタイル">スタイル</a></em>, <em><a href="#コレクション-性能">性能</a></em>, <em><a href="#コレクション-Javaコレクション">Javaコレクション</a></em></li>
<li><strong><a href="#Concurrency">Concurrency</a></strong>: <em><a href="#Concurrency-Futures">Futures</a></em>, <em><a href="#Concurrency-Collections">Collections</a></em></li>
<li><strong><a href="#Control structures">Control structures</a></strong>: <em><a href="#Control structures-Recursion">Recursion</a></em>, <em><a href="#Control structures-Returns">Returns</a></em>, <em><a href="#Control structures-`for` loops and comprehensions"><code>for</code> loops and comprehensions</a></em>, <em><a href="#Control structures-`require` and `assert`"><code>require</code> and <code>assert</code></a></em></li>
<li><strong><a href="#Functional programming">Functional programming</a></strong>: <em><a href="#Functional programming-Case classes as algebraic data types">Case classes as algebraic data types</a></em>, <em><a href="#Functional programming-Options">Options</a></em>, <em><a href="#Functional programming-Pattern matching">Pattern matching</a></em>, <em><a href="#Functional programming-Partial functions">Partial functions</a></em>, <em><a href="#Functional programming-Destructuring bindings">Destructuring bindings</a></em>, <em><a href="#Functional programming-Lazyness">Lazyness</a></em>, <em><a href="#Functional programming-Call by name">Call by name</a></em>, <em><a href="#Functional programming-`flatMap`"><code>flatMap</code></a></em></li>
<li><strong><a href="#Object oriented programming">Object oriented programming</a></strong>: <em><a href="#Object oriented programming-Dependency injection">Dependency injection</a></em>, <em><a href="#Object oriented programming-Traits">Traits</a></em>, <em><a href="#Object oriented programming-Visibility">Visibility</a></em>, <em><a href="#Object oriented programming-Structural typing">Structural typing</a></em></li>
<li><strong><a href="#Garbage collection">Garbage collection</a></strong></li>
<li><strong><a href="#Java compatibility">Java compatibility</a></strong></li>
<li><strong><a href="#Twitter's standard libraries">Twitter&rsquo;s standard libraries</a></strong>: <em><a href="#Twitter's standard libraries-Futures">Futures</a></em></li>
<li><strong><a href="#Acknowledgments">Acknowledgments</a></strong></li>
</ul>

<h2>他の言語</h2>

<p><a href="index.html">English</a></p>

<p><a id="序章" /></p>

<h2>序章</h2>

<p><a href="http://www.scala-lang.org/">Scala</a>は、Twitterで使われている主なアプリケーションプログラミング言語の一つだ。TwitterのインフラのほとんどはScalaで書かれているし、我々の業務を支える<a href="http://github.com/twitter/">大規模ライブラリ</a>をいくつか持っている。Scalaは極めて効率的だが、一方で大きな言語でもある。我々の経験上、Scalaの適用には細心の注意が必要だ。Scalaの落とし穴は何か？ どの機能を採用し、どれを避けるべきか？ いつ&ldquo;純粋関数型スタイル&rdquo;を用い、いつ控えるべきか？ つまり、我々が見出した&ldquo;Scalaの効果的(effective)な使い方&rdquo;とは何か？ このガイドは、我々の経験を抽出し、一連の<em>ベストプラクティス</em>を提供する小論文にまとめようとするものだ。Twitterは、Scalaを、主に分散システムを構成する大容量サービスの作成に利用している。だから、我々の助言にはバイアスがかかっている。しかし、ここにあるアドバイスのほとんどは、他の問題領域へも自然に置き換えることができるはずだ。これは法律じゃない、だから逸脱は正当化されるべきだ。</p>

<p>Scalaは、簡潔な表現を可能にする数多くのツールを提供している。タイピングが少なければ、読む量も少なくなり、読む量が少なくなれば、大抵はより早く読める。故に、簡潔さは明瞭さを高める。しかし、簡潔さはまた、正反対の効果をもたらす使い勝手の悪い道具ともなりえる。正確さの次に、いつも読み手のことを考えよう。</p>

<p>何よりも、<em>Scalaでプログラムするのだ</em>。君が書いているのはJavaではないし、Haskellでも、Pythonでもない。Scalaのプログラムは、それらのうちのいずれの言語で書かれたものとも違っている。Scalaを効果的に使うには、君の問題をScalaの用語で表現しなければならない。Javaのプログラムを、無理矢理にScalaになおしても仕方がない。ほとんどのやり方で、それはオリジナルより劣ったものになるだろう。</p>

<p>これは、Scalaの入門じゃない。読者は、Scalaに慣れ親しんでいることを前提としている。これからScalaを学びたい人は、以下のサイトを参照するといいだろう:</p>

<ul>
<li><a href="http://twitter.github.com/scala_school/">Scala School</a></li>
<li><a href="http://www.scala-lang.org/node/1305">Learning Scala</a></li>
<li><a href="http://matt.might.net/articles/learning-scala-in-small-bites/">Learning Scala in Small Bites</a></li>
</ul>

<p>このガイドは生きたドキュメントであり、現在の「ベストプラクティス」が反映されていく。けれども、核となるアイデアは変わらない。常に可読性を優先せよ。ジェネリックなコードを書き、しかし明瞭さを犠牲にするな。シンプルな言語機能を利用せよ。それは偉大な力を与え、難解さを防ぐ（型システムでは特に）。とりわけ、トレードオフを常に意識すべきだ。洗練された言語は複雑な実装を必要とし、判断や、動作や、機能間の相互作用や、そして君の協力者に対する理解を困難にする。つまり、複雑さは洗練の税金なのだ。効用がコストを上回っていることを、常に確認しなければいけない。</p>

<p>では、楽しんでほしい。</p>

<p><a id="整形" /></p>

<h2>整形</h2>

<p>コード<em>整形</em>の詳細は、（それが実際的である限りは）重要じゃない。当然だが、スタイルに本質的な良し悪しはないし、たいていは人それぞれの個人的嗜好は異なる。だけど、同じ整形ルールを<em>一貫して</em>適用することは、ほぼ全ての場合で可読性を高める。特定のスタイルに馴染んだ読み手は、さらに他のローカルな習慣を理解したり、言語文法の隅っこを解読したりする必要がない。</p>

<p>これは文法の重複度が高いScalaにおいては特に重要だ。メソッド呼び出しを例に挙げよう。メソッドは、&ldquo;<code>.</code>&rdquo;を付けても、ホワイトスペースを付けても呼び出せる。同様に、ゼロまたは一つの引数を取るメソッドでは丸カッコを付けても良いし、付けなくても良い、といった風に。さらに、異なるスタイルのメソッド呼び出しは、異なる文法上の曖昧さを露呈する！ 注意深く選ばれた整形ルールを一貫して適用することで、人間と機械の両方にとって、多くの曖昧さを解決できるのは間違いない。</p>

<p>我々は、<a href="http://docs.scala-lang.org/style/">Scala style guide</a>を遵守すると同時に、以下に示すルールを追加した。</p>

<p><a id="整形-ホワイトスペース" /></p>

<h3>ホワイトスペース</h3>

<p>インデントはホワイトスペース2個。100カラムを超える行は避けよう。メソッドやクラス、オブジェクトの定義の間は一行空ける。</p>

<p><a id="整形-命名" /></p>

<h3>命名</h3>

<dl class="rules">
<dt>小さなスコープでは、短い名前を使う</dt>
<dd> <code>i</code>や<code>j</code>や<code>k</code>は、ループ内ではほとんど期待される。</dd>
<dt>より大きなスコープでは、より長い名前を使う</dt>
<dd>外部APIには、より長く意味のある説明的な名前を付けるべきだ。<code>Future.all</code>ではなく<code>Future.collect</code>のような。
</dd>
<dt>一般的な略語を使い、難解な略語を避ける</dt>
<dd>誰でも<code>ok</code>や<code>err</code>、<code>defn</code>が何を指すか知っている。一方で、<code>sfri</code>はそれほど一般的じゃない。</dd>
<dt>用法が異なるのに名前を再利用しない</dt>
<dd><code>val</code>を使おう。</dd>
<dt>予約名を <code>`</code> を使ってオーバーロードするのは避ける</dt>
<dd><code>`type</code>`の代わりに、<code>typ</code>とする。</dd>
<dt>副作用を伴う操作には動作を表す名前を付ける（訳注：能動態？）</dt>
<dd><code>user.setActive()</code>ではなく、<code>user.activate()</code>とする。</dd>
<dt>値を返すメソッドの名前は説明的に</dt>
<dd><code>src.defined</code>ではなく、<code>src.isDefined</code>とする。</dd>
<dt>getterの接頭に<code>get</code>を付けない</dt>
<dd>以前のルールの通り、これは冗長だ。<code>site.getCount</code>ではなく、<code>site.count</code>とする。</dd>
<dt>パッケージやオブジェクト内で既にカプセル化されている名前を繰り返さない</dt>
<dd><pre><code>object User {
  def getUser(id: Int): Option[User]
}</code></pre>よりも、
<pre><code>object User {
  def get(id: Int): Option[User]
}</code></pre>とする。<code>User.get</code>に比べて、<code>User.getUser</code>は何も情報を提供しないし、使うときに冗長だ。
</dd>
</dl>

<p><a id="整形-インポート" /></p>

<h3>インポート</h3>

<dl class="rules">
<dt>インポート行はアルファベット順にソートする</dt>
<dd>こうすることで、視覚的に調べやすいし自動化もしやすい。</dd>
<dt>同じパッケージから複数の名前をインポートするときは中カッコを使う</dt>
<dd><code>import com.twitter.concurrent.{Broker, Offer}</code></dd>
<dt>6つより多くの名前をインポートするときはワイルドカードを使う</dt>
<dd>e.g.: <code>import com.twitter.concurrent._</code>
<br />ワイルドカードを濫用しないこと。一部のパッケージは、大量の名前をエクスポートしている。</dd>
<dt>コレクションを使う時は、<code>scala.collections.immutable</code> あるいは <code>scala.collections.mutable</code> をインポートして名前を修飾する</dt>
<dd>可変(mutable)および不変(immutable)コレクションは、二重に名前を持っている。読み手のために、名前を修飾してどちらのコレクションを使っているのか明らかにしよう。 (e.g. "<code>immutable.Map</code>")</dd>
<dt>他のパッケージからの相対指定でインポートしない</dt>
<dd><pre><code>import com.twitter
import concurrent</code></pre>のようには書かず、以下のように曖昧さの無い書き方をしよう。<pre><code>import com.twitter.concurrent</code></pre></dd>
<dt>インポートはファイルの先頭に置く</dt>
<dd>読み手が、全てのインポートを一箇所で参照できるようにしよう。</dd>
</dl>

<p><a id="整形-中カッコ" /></p>

<h3>中カッコ</h3>

<p>中カッコは、複合式を作るのに使われる（&ldquo;モジュール言語&rdquo;では他の用途にも使われる）。そして、複合式の値は、リスト中の最後の式となる。単純な式に中カッコを使うのは避けよう。例えば、</p>

<pre><code>def square(x: Int) = x*x
</code></pre>

<p class="LP">と書く代わりに、構文的にメソッドの本体を見分けやすい</p>

<pre><code>def square(x: Int) = {
  x * x
}
</code></pre>

<p class="LP">と書きたいと思うかもしれない。しかし、最初の記法の方が、乱雑さが少なく読みやすい。明確にするのが目的でないなら、<em>構文的な儀礼</em>は避けよう。</p>

<p><a id="整形-パターンマッチ" /></p>

<h3>パターンマッチ</h3>

<p>適用できる場合は、関数定義の中ではパターンマッチを直接使おう。</p>

<pre><code>list map { item =&gt;
  item match {
    case Some(x) =&gt; x
    case None =&gt; default
  }
}
</code></pre>

<p class="LP">とする代わりに、matchを折り畳んで</p>

<pre><code>list map {
  case Some(x) =&gt; x
  case None =&gt; default
}
</code></pre>

<p class="LP">と書くと、リストの要素がmapされることが分かりやすい &mdash; the extra indirection does not elucidate. （←？）</p>

<p><a id="整形-コメント" /></p>

<h3>コメント</h3>

<p><a href="https://wiki.scala-lang.org/display/SW/Scaladoc">ScalaDoc</a>を使ってAPIドキュメントを提供しよう。以下のように書く:</p>

<pre><code>/**
 * ServiceBuilder builds services 
 * ...
 */
</code></pre>

<p class="LP">しかし、以下は標準のScalaDocスタイル<em>ではない</em>:</p>

<pre><code>/** ServiceBuilder builds services
 * ...
 */
</code></pre>

<p>アスキーアートや視覚的な装飾に頼ってはいけない。また、APIではない不必要なコメントをドキュメント化してはいけない。もし、自分のコードの挙動を説明するためにコメントを追加しているのに気づいたら、まずは、それが何をするコードなのか明白になるよう書き直せないか考え直してみよう。「見るからに、それは動作する (it works, obviously)」よりも「明らかにそれは動作する(obviously it works)」方が良い（ホーアには申し訳ないけど）。</p>

<p>（訳注: <a href="http://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%B3%E3%83%88%E3%83%8B%E3%83%BC%E3%83%BB%E3%83%9B%E3%83%BC%E3%82%A2">アントニー・ホーア</a>は、自身のチューリング賞受賞講演の中で、<em>『極めて複雑に設計して「明らかな」欠陥を無くすより、非常に簡素に設計して「明らかに」欠陥が無いようにする方が遥かに難しい』</em>という趣旨の発言をしている。「コードから実装の意図を一目瞭然に読み取れるようにせよ」という主張は、上記のホーアの主張の真逆を言っている、ということだろう。）</p>

<p><a id="型とジェネリクス" /></p>

<h2>型とジェネリクス</h2>

<p>型システムの主な目的は、プログラミングの誤りを検出することだ。型システムは、限定的な方式の静的検査を効果的に提供する。これにより、コンパイラが検証可能なコードにおいて、ある種の不変条件を表現できる。型システムがもたらす恩恵はもちろん他にもあるが、エラーチェックこそ、その存在理由（レーゾンデートル）だ。</p>

<p>我々が型システムを使う場合はこの目的を踏まえるべきだが、一方で、読み手にも気を配り続けなきゃいけない。型を慎重に使ったコードは明瞭さが高まるが、過剰に巧妙に使ったコードは読みにくいだけだ。</p>

<p>Scalaの強力な型システムは、学術的な探求と演習においてよく題材とされる(eg. <a href="http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/">Type level programming in
Scala</a>)。これらのテクニックは学術的に興味深いトピックだが、プロダクションコードでの応用において有用であることは稀だ。避けるべきだろう。</p>

<p><a id="型とジェネリクス-戻り型アノテーション" /></p>

<h3>戻り型アノテーション</h3>

<p>Scalaでは戻り型アノテーション(return type annotation)を省略できるが、一方でそれらは良いドキュメンテーションであり、publicメソッドでは特に重要だ。露出していないメソッドで、戻り型が明白な場合は省略しよう。</p>

<p>これは、Scalaコンパイラが生成するシングルトン型をミックスインするオブジェクトをインスタンス化する場合は特に重要だ。例えば、<code>make</code> 関数が:</p>

<pre><code>trait Service
def make() = new Service {
  def getId = 123
}
</code></pre>

<p class="LP"><code>Service</code> という戻り型を<em>持たない</em>場合、コンパイラは細別型(refinement type)である <code>Object with Service{def getId: Int}</code> を生成する。代わりに、明示的なアノテーションを使うと:</p>

<pre><code>def make(): Service = new Service{}
</code></pre>

<p><code>make</code> の公開型を変更することなく、さらに好きなだけtraitをミックスできるから、後方互換性の管理が容易になる。</p>

<p><a id="型とジェネリクス-変位" /></p>

<h3>変位</h3>

<p>変位(variance)は、ジェネリクスが派生型と結びつく時に現れる。変位は、<em>コンテナ型</em>の派生型と、コンテナ型に<em>含まれる型</em>の派生型がどう関連するかを定義する。Scalaでは変位アノテーションを宣言できるから、コレクションに代表される共通ライブラリの作者は、多数のアノテーションを扱う必要がある。変位アノテーションは、共用コードの使い勝手を高める上で重要だが、誤用すると危険なものとなりうる。</p>

<p>変位は、Scalaの型システムにおいて、高度だが必須の特徴だ。変位は、派生型の適用を助けるものとして、大いに（そして正しく）使われるべきだ。</p>

<p><em>不変コレクションは共変であるべきだ</em>。要素型を受け取るメソッドは、コレクションを適切に&ldquo;格下げ&rdquo;すべきだ:</p>

<pre><code>trait Collection[+T] {
  def add[U &gt;: T](other: U): Collection[U]
}
</code></pre>

<p><em>可変コレクションは不変であるべきだ</em>。一般的に、可変コレクションにおいて共変は無効だ。この</p>

<pre><code>trait HashSet[+T] {
  def add[U &gt;: T](item: U)
}
</code></pre>

<p class="LP">と、以下の型階層を見てほしい:</p>

<pre><code>trait Mammal
trait Dog extends Mammal
trait Cat extends Mammal
</code></pre>

<p class="LP">もし今、犬(Dog)のハッシュセットがあるなら、</p>

<pre><code>val dogs: HashSet[Dog]
</code></pre>

<p class="LP">それを哺乳類(Mammal)の集合として扱ったり、猫(Cat)を追加したりできる。</p>

<pre><code>val mammals: HashSet[Mammal] = dogs
mammals.add(new Cat{})
</code></pre>

<p class="LP">これはもはや、犬のHashSetではない！</p>

<!--
  * when to use abstract type members?
  * show contravariance trick?
-->

<p><a id="型とジェネリクス-型エイリアス" /></p>

<h3>型エイリアス</h3>

<p>型エイリアス(type alias)は、簡便な名前を提供したり、意味を明瞭にするために使う。しかし、一目瞭然な型はエイリアスしない。</p>

<pre><code>() =&gt; Int
</code></pre>

<p class="LP">は、簡潔かつ一般的な型を使っているので、</p>

<pre><code>type IntMaker = () =&gt; Int
IntMaker
</code></pre>

<p class="LP">よりも明瞭だ。しかし、</p>

<pre><code>class ConcurrentPool[K, V] {
  type Queue = ConcurrentLinkedQueue[V]
  type Map   = ConcurrentHashMap[K, Queue]
  ...
}
</code></pre>

<p class="LP">は、意思疎通が目的で、簡潔さを高めたい場合に有用だ。</p>

<p>エイリアスが使える場合は、サブクラスを使ってはいけない。</p>

<pre><code>trait SocketFactory extends (SocketAddress) =&gt; Socket
</code></pre>

<p class="LP"><code>SocketFactory</code>は、<code>Socket</code>を生成する<em>関数</em>だ。型エイリアス</p>

<pre><code>type SocketFactory = SocketAddress =&gt; Socket
</code></pre>

<p class="LP">を使う方がいい。今や、<code>SocketFactory</code>型の値のための関数リテラルが与えられているので、関数合成を使うことができる:</p>

<pre><code>val addrToInet: SocketAddress =&gt; Long
val inetToSocket: Long =&gt; Socket

val factory: SocketFactory = addrToInet andThen inetToSocket
</code></pre>

<p>パッケージオブジェクトを使うと、型エイリアスをトップレベル名に結びつけられる:</p>

<pre><code>package com.twitter
package object net {
  type SocketFactory = (SocketAddress) =&gt; Socket
}
</code></pre>

<p>なお、型エイリアスは、型に対する別名の構文的な代わりとなるものであり、新しい型ではないことに留意しよう。</p>

<p><a id="型とジェネリクス-暗黙" /></p>

<h3>暗黙</h3>

<p>暗黙(implicit)は、型システムの強力な機能だが、慎重に使うべきだ。それらの解決ルールは複雑で、シンプルな字句検査においてさえ、実際に何が起きているか把握するのを困難にする。暗黙を間違いなく使ってもいいのは、以下の場面だ:</p>

<ul>
<li>Scalaスタイルのコレクションを拡張したり、追加したりするとき</li>
<li>オブジェクトを適合(adapt)させたり、拡張したりするとき（&ldquo;pimp my library&rdquo;パターン）</li>
<li><a href="http://www.ne.jp/asahi/hishidama/home/tech/scala/generics.html#h_generalized_type_constraints">制約エビデンス</a>を提供することで、<em>型安全を強化</em>するために使うとき</li>
<li>型エビデンス（型クラス）を提供するため</li>
<li><code>Manifest</code>のため</li>
</ul>

<p>暗黙を使う場合は、暗黙を使わずに同じことを達成する方法がないか、常に確認しよう。</p>

<p>似通ったデータ型同士を、自動的に変換するのに暗黙を使うのはやめよう（例えば、リストをストリームに変換する等）。型はそれぞれ異なった動作をするので、暗黙に型が変換されていないか、読み手に気を使わせることになる。明示的に変換するべきだ。</p>

<p><a id="コレクション" /></p>

<h2>コレクション</h2>

<p>Scalaが持つコレクションライブラリは、非常に総称的で、機能豊富で、強力で、組み合わせが容易だ。コレクションは高水準であり、多数の操作を提供している。多数のコレクション操作と変換を簡潔かつ読みやすく表現できるが、それらの機能を不注意に適用すると、しばしば正反対の結果を招く。全てのScalaプログラマは、<a href="http://www.scala-lang.org/docu/files/collections-api/collections.html">collections design document</a>を読むべきだ。このドキュメントは、Scalaのコレクションライブラリに対する優れた洞察と意欲をもたらしてくれる。</p>

<p>常に、君のニーズを最もシンプルに満たすコレクションを使おう。</p>

<p><a id="コレクション-階層" /></p>

<h3>階層</h3>

<p>コレクションライブラリは巨大だ。<code>Traversable[T]</code>を基底とする精密な階層に加えて、ほとんどのコレクションに<code>immutable</code>と<code>mutable</code>のバリエーションがある。複雑さはともかく、以下の図は、<code>immutable</code>と<code>mutable</code>の双方の階層にとって重要な区別を含んでいる。</p>

<p><img src="coll.png" style="margin-left: 3em;" /></p>

<p class="LP"><code>Iterable[T]</code>はイテレートできるコレクションで、<code>iterator</code>(と<code>foreach</code>)メソッドを提供する。<code>Seq[T]</code>は<em>順序付けされた</em>コレクション、<code>Set[T]</code>は数学的集合（要素が一意な順序の無いコレクション）、そして<code>Map[T]</code>は順序の無い連想配列だ。</p>

<p><a id="コレクション-利用" /></p>

<h3>利用</h3>

<p><em>不変(immutable)コレクションを利用する。</em>不変コレクションは、ほとんどの状況に適用できると同時に参照透過なので、プログラムがデフォルトでスレッドセーフであると判断しやすくなる。</p>

<p><em><code>mutable</code>名前空間は明示的に使う。</em><code>scala.collections.mutable._</code>をインポートして<code>Set</code>を参照する代わりに、</p>

<pre><code>import scala.collections.mutable
val set = mutable.Set()
</code></pre>

<p class="LP">とすることで、可変な`Set`を使っていることが分かりやすくなる。</p>

<p><em>コレクション型のデフォルトコンストラクタを使う。</em>例えば、順序付きの（かつ連結リストの動作が必要ない）シーケンスが欲しい場合は、いつでも<code>Seq()</code>コンストラクタを使おう:</p>

<pre><code>val seq = Seq(1, 2, 3)
val set = Set(1, 2, 3)
val map = Map(1 -&gt; &quot;one&quot;, 2 -&gt; &quot;two&quot;, 3 -&gt; &quot;three&quot;)
</code></pre>

<p class="LP">このスタイルでは、コレクションの動作がその実装と切り離されているので、コレクションライブラリは最も適切な実装型を使うことができる。君が必要としているのは<code>Map</code>であって、必ずしも赤黒木じゃない。さらに、これらのデフォルトコンストラクタは、しばしば特殊化した表現を用いる。例えば<code>Map()</code>は、3つのキーを持つマップに対して、3つのフィールドを持つオブジェクトを使う（訳注: [Map3](http://www.scala-lang.org/api/current/scala/collection/immutable/Map$$Map3.html)クラスのこと）。</p>

<p>以上からの結論として、メソッドやコンストラクタでは、<em>最も総称的なコレクション型を適切に受け取ろう</em>。これは詰まるところ、通常は上記の<code>Iterable</code>、<code>Seq</code>、<code>Set</code>あるいは<code>Map</code>のうち、どれか一つである。もしメソッドがシーケンスを必要とする場合は、<code>List[T]</code>ではなく<code>Seq[T]</code>を使おう。</p>

<!--
something about buffers for construction?
anything about streams?
-->

<p><a id="コレクション-スタイル" /></p>

<h3>スタイル</h3>

<p>関数型プログラミングでは、不変コレクションを望みの結果へと変形する方法として、パイプライン化された変換が推奨されている。大抵は、この手法により問題をとても簡潔に解決できるが、同時に読み手を困惑させることもある。変換をパイプライン化すると、しばしば作者の意図を理解するのが困難になり、暗黙的にしか示されていない途中結果を、全て追跡し続けるしかなくなるからだ。例えば、様々なプログラミング言語に対する投票結果である (language, num votes) のシーケンスを集計して、票数の最も多い言語から順番に表示するコードは、以下のように書ける:</p>

<pre><code>val votes = Seq((&quot;scala&quot;, 1), (&quot;java&quot;, 4), (&quot;scala&quot;, 10), (&quot;scala&quot;, 1), (&quot;python&quot;, 10))
val orderedVotes = votes
  .groupBy(_._1)
  .map { case (which, counts) =&gt; 
    (which, counts.foldLeft(0)(_ + _._2))
  }.toSeq
  .sortBy(_._2)
  .reverse
</code></pre>

<p class="LP">このコードは、簡潔でかつ正しい。しかし、ほとんどの読み手は、作者の元の意図を把握するのに苦労するだろう。<em>途中結果とパラメータに名前を付ける</em>のは、多くの場合で、作者の意図をハッキリさせるのに役立つ戦略の一つだ:</p>

<pre><code>val votesByLang = votes groupBy { case (lang, _) =&gt; lang }
val sumByLang = votesByLang map { case (lang, counts) =&gt;
  val countsOnly = counts map { case (_, count) =&gt; count }
  (lang, countsOnly.sum)
}
val orderedVotes = sumByLang.toSeq
  .sortBy { case (_, count) =&gt; count }
  .reverse
</code></pre>

<p class="LP">このコードでは、施される変換を中間値の名前に、操作されるデータ構造をパラメータ名にしている。これにより、以前と同じくらい簡潔であるだけでなく、作者の意図がよりいっそう明瞭に表現されている。もし、このスタイルを使うことで名前空間の汚染が心配なら、式を<code>{}</code>でグループ化すると良い:</p>

<pre><code>val orderedVotes = {
  val votesByLang = ...
  ...
}
</code></pre>

<p><a id="コレクション-性能" /></p>

<h3>性能</h3>

<p>高水準コレクションライブラリは、（高水準な構築物が一般的にそうであるように）性能の推測が難しい。コンピュータに直接指示するやり方、つまり命令型スタイルから遠ざかるほど、あるコード片が性能に与える影響を厳密に予測するのは困難になる。一方で、正確さを判断することは概して容易だし、読みやすさも向上する。Scalaの場合、Javaランタイムが事態をさらに複雑にしている。Scalaでは、ボクシング操作やアンボクシング操作がユーザから隠されており、性能やメモリ使用量の面で重大なペナルティを被ることがある。</p>

<p>低レベルの詳細に焦点を当てる前に、君のコレクションの使い方が適切かどうか確認しよう。また、データ構造に予期しない漸近的な複雑さがないか確かめよう。Scalaのさまざまなコレクションの複雑さについては、<a href="http://www.scala-lang.org/docu/files/collections-api/collections_40.html">こちら</a>で述べられている。</p>

<p>性能最適化の第一法則は、君のアプリケーションが<em>なぜ</em>遅いのかを理解することだ。最適化を始める前に、君のアプリケーションをプロファイル<a class="noteref" id="fnref1" href="#fn1" title="Jump to note 1">[1]</a>してデータを取ろう。最初に注目するのは、回数の多いループや巨大なデータ構造だ。最適化への過度な取り組みは、たいてい無駄な努力に終わる。クヌースの「時期尚早な最適化は諸悪の根源」という格言を思い出そう。</p>

<p>性能やメモリ使用効率の良さが要求される場面では、多くの場合、低レベルコレクションを使うのが妥当だ。巨大なシーケンスには、リストより配列を使おう（不変の<code>Vector</code>コレクションは、配列への参照透過なインタフェースを提供する）。また、性能が重要な場合は、シーケンスを直接生成せずにバッファを使おう。</p>

<p><a id="コレクション-Javaコレクション" /></p>

<h3>Javaコレクション</h3>

<p>Javaコレクションとの相互運用のために、<code>scala.collection.JavaConverters</code>を使おう。<code>JavaConverters</code>は、暗黙変換を行う<code>asJava</code>メソッドと<code>asScala</code>メソッドを追加する。読み手を助けるために、これらの変換は明示的に行うようにしよう:</p>

<pre><code>import scala.collection.JavaConverters._

val list: java.util.List[Int] = Seq(1,2,3,4).asJava
val buffer: scala.collection.mutable.Buffer[Int] = list.asScala
</code></pre>

<p><a id="Concurrency" /></p>

<h2>Concurrency</h2>

<p>Modern services are highly concurrent &mdash; it is common for servers to
coordinate 10s&ndash;100s of thousands of simultaneous operations &mdash; and
handling the implied complexity is a central theme in authoring robust
systems software.</p>

<p><em>Threads</em> provide a means of expressing concurrency: they give you
independent, heap-sharing execution contexts that are scheduled by the
operating system. However, thread creation is expensive in Java and is
a resource that must be managed, typically with the use of pools. This
creates additional complexity for the programmer, and also a high
degree of coupling: it&rsquo;s difficult to divorce application logic from
their use of the underlying resources.</p>

<p>This complexity is especially apparent when creating services that
have a high degree of fan-out: each incoming request results in a
multitude of requests to yet another tier of systems. In these
systems, thread pools must be managed so that they are balanced
according to the ratios of requests in each tier: mismanagement of one
thread pool bleeds into another. </p>

<p>Robust systems must also consider timeouts and cancellation, both of
which require the introduction of yet more &ldquo;control&rdquo; threads,
complicating the problem further. Note that if threads were cheap
these problems would be diminished: no pooling would be required,
timed out threads could be discarded, and no additional resource
management would be required.</p>

<p>Thus resource management compromises modularity.</p>

<p><a id="Concurrency-Futures" /></p>

<h3>Futures</h3>

<p>Use Futures to manage concurrency. They decouple
concurrent operations from resource management: for example, <a href="http://github.com/twitter/finagle">Finagle</a>
multiplexes concurrent operations onto few threads in an efficient
manner. Scala has lightweight closure literal syntax, so Futures
introduce little syntactic overhead, and they become second nature to
most programmers.</p>

<p>Futures allow the programmer to express concurrent computation in a
declarative style, are composable, and have principled handling of
failure. These qualities has convinced us that they are especially
well suited for use in functional programming languages, where this is
the encouraged style.</p>

<p><em>Prefer transforming futures over creating your own.</em> Future
transformations ensure that failures are propagated, that
cancellations are signalled, and frees the programmer from thinking
about the implications of the Java memory model. Even a careful
programmer might write the following to issue an RPC 10 times in
sequence and then print the results:</p>

<pre><code>val p = new Promise[List[Result]]
var results: List[Result] = Nil
def collect() {
  doRpc() onSuccess { result =&gt;
    results = result :: results
    if (results.length &lt; 10)
      collect()
    else
      p.setValue(results)
  } onFailure { t =&gt;
    p.setException(t)
  }
}

collect()
p onSuccess { results =&gt;
  printf(&quot;Got results %s\n&quot;, results.mkString(&quot;, &quot;))
}
</code></pre>

<p>The programmer had to ensure that RPC failures are propagated,
interspersing the code with control flow; worse, the code is wrong!
Without declaring <code>results</code> volatile, we cannot ensure that <code>results</code>
holds the previous value in each iteration. The Java memory model is a
subtle beast, but luckily we can avoid all of these pitfalls by using
the declarative style:</p>

<pre><code>def collect(results: List[Result] = Nil): Future[List[Result]] =
  doRpc() flatMap { result =&gt;
    if (results.length &lt; 9)
      collect(result :: results)
    else
      result :: results
  }

collect() onSuccess { results =&gt;
  printf(&quot;Got results %s\n&quot;, results.mkString(&quot;, &quot;))
}
</code></pre>

<p>We use <code>flatMap</code> to sequence operations and prepend the result onto
the list as we proceed. This is a common functional programming idiom
translated to Futures. This is correct, requires less boilerplate, is
less error prone, and also reads better.</p>

<p><em>Use the Future combinators</em>. <code>Future.select</code>, <code>Future.join</code>, and
<code>Future.collect</code> codify common patterns when operating over
multiple futures that should be combined.</p>

<p><a id="Concurrency-Collections" /></p>

<h3>Collections</h3>

<p>The subject of concurrent collections is fraught with opinions,
subtleties, dogma and FUD. In most practical situations they are a
nonissue: Always start with the simplest, most boring, and most
standard collection that serves the purpose. Don&rsquo;t reach for a
concurrent collection before you <em>know</em> that a synchronized one won&rsquo;t
do: the JVM has sophisticated machinery to make synchronization cheap,
so their efficacy may surprise you.</p>

<p>If an immutable collection will do, use it &mdash; they are referentially
transparent, so reasoning about them in a concurrent context is
simple. Mutations in immutable collections are typically handled by
updating a reference to the current value (in a <code>var</code> cell or an
<code>AtomicReference</code>). Care must be taken to apply these correctly:
atomics must be retried, and <code>vars</code> must be declared volatile in order
for them to be published to other threads.</p>

<p>Mutable concurrent collections have complicated semantics, and make
use of subtler aspects of the Java memory model, so make sure you
understand the implications &mdash; especially with respect to publishing
updates &mdash; before you use them. Synchronized collections also compose
better: operations like <code>getOrElseUpdate</code> cannot be implemented
correctly by concurrent collections, and creating composite
collections is especially error prone.</p>

<!--

use the stupid collections first, get fancy only when justified.

serialized? synchronized?

blah blah.

Async*?

-->

<p><a id="Control structures" /></p>

<h2>Control structures</h2>

<p>Programs in the functional style tends to require fewer traditional
control structure, and read better when written in the declarative
style. This typically implies breaking your logic up into several
small methods or functions, and gluing them together with <code>match</code>
expressions. Functional programs also tend to be more
expression-oriented: branches of conditionals compute values of
the same type, <code>for (..) yield</code> computes comprehensions, and recursion
is commonplace.</p>

<p><a id="Control structures-Recursion" /></p>

<h3>Recursion</h3>

<p><em>Phrasing your problem in recursive terms often simplifies it,</em> and if
the tail call optimization applies (which can be checked by the <code>@tailrec</code>
annotation), the compiler will even translate your code into a regular loop.</p>

<p>Consider a fairly standard imperative version of heap <span
class="algo">fix-down</span>:</p>

<pre><code>def fixDown(heap: Array[T], m: Int, n: Int): Unit = {
  var k: Int = m
  while (n &gt;= 2*k) {
    var j = 2*k
    if (j &lt; n &amp;&amp; heap(j) &lt; heap(j + 1))
      j += 1
    if (heap(k) &gt;= heap(j))
      return
    else {
      swap(heap, k, j)
      k = j
    }
  }
}
</code></pre>

<p>Every time the while loop is entered, we&rsquo;re working with state dirtied
by the previous iteration. The value of each variable is a function of
which branches were taken, and it returns in the middle of the loop
when the correct position was found (The keen reader will find similar
arguments in Dijkstra&rsquo;s <a href="http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html">&ldquo;Go To Statement Considered Harmful&rdquo;</a>).</p>

<p>Consider a (tail) recursive
implementation<a class="noteref" id="fnref2" href="#fn2" title="Jump to note 2">[2]</a>:</p>

<pre><code>@tailrec
final def fixDown(heap: Array[T], i: Int, j: Int) {
  if (j &lt; i*2) return

  val m = if (j == i*2 || heap(2*i) &lt; heap(2*i+1)) 2*i else 2*i + 1
  if (heap(m) &lt; heap(i)) {
    swap(heap, i, m)
    fixDown(heap, m, j)
  }
}
</code></pre>

<p class="LP">here every iteration starts with a well-defined <em>clean slate</em>, and there are no reference cells: invariants abound. It&rsquo;s much easier to reason about, and easier to read as well. There is also no performance penalty: since the method is tail-recursive, the compiler translates this into a standard imperative loop.</p>

<!--
elaborate..
-->

<p><a id="Control structures-Returns" /></p>

<h3>Returns</h3>

<p>This is not to say that imperative structures are not also valuable.
In many cases they are well suited to terminate computation early
instead of having conditional branches for every possible point of
termination: indeed in the above <code>fixDown</code>, a <code>return</code> is used to
terminate early if we&rsquo;re at the end of the heap.</p>

<p>Returns can be used to cut down on branching and establish invariants.
This helps the reader by reducing nesting (how did I get here?) and
making it easier to reason about the correctness of subsequent code
(the array cannot be accessed out of bounds after this point). This is
especially useful in &ldquo;guard&rdquo; clauses:</p>

<pre><code>def compare(a: AnyRef, b: AnyRef): Int = {
  if (a eq b)
    return 0

  val d = System.identityHashCode(a) compare System.identityHashCode(b)
  if (d != 0)
    return d

  // slow path..
}
</code></pre>

<p>Use <code>return</code>s to clarify and enhance readability, but not as you would
in an imperative language; avoid using them to return the results of a
computation. Instead of</p>

<pre><code>def suffix(i: Int) = {
  if      (i == 1) return &quot;st&quot;
  else if (i == 2) return &quot;nd&quot;
  else if (i == 3) return &quot;rd&quot;
  else             return &quot;th&quot;
}
</code></pre>

<p class="LP">prefer:</p>

<pre><code>def suffix(i: Int) =
  if      (i == 1) &quot;st&quot;
  else if (i == 2) &quot;nd&quot;
  else if (i == 3) &quot;rd&quot;
  else             &quot;th&quot;
</code></pre>

<p class="LP">but using a <code>match</code> expression is superior to either:</p>

<pre><code>def suffix(i: Int) = i match {
  case 1 =&gt; &quot;st&quot;
  case 2 =&gt; &quot;nd&quot;
  case 3 =&gt; &quot;rd&quot;
  case _ =&gt; &quot;th&quot;
}
</code></pre>

<p>Note that returns can have hidden costs: when used inside of a closure,</p>

<pre><code>seq foreach { elem =&gt;
  if (elem.isLast)
    return

  // process...
}
</code></pre>

<p class="LP">this is implemented in bytecode as an exception catching/throwing pair which, used in hot code, has performance implications.</p>

<p><a id="Control structures-`for` loops and comprehensions" /></p>

<h3><code>for</code> loops and comprehensions</h3>

<p><code>for</code> provides both succinct and natural expression for looping and
aggregation. It is especially useful when flattening many sequences.
The syntax of <code>for</code> belies the underlying mechanism as it allocates
and dispatches closures. This can lead to both unexpected costs and
semantics; for example</p>

<pre><code>for (item &lt;- container) {
  if (item != 2) return
}
</code></pre>

<p class="LP">may cause a runtime error if the container delays computation, making the <code>return</code> nonlocal!</p>

<p>For these reasons, it is often preferrable to call <code>foreach</code>,
<code>flatMap</code>, <code>map</code>, and <code>filter</code> directly &mdash; but do use <code>for</code>s when they
clarify.</p>

<p><a id="Control structures-`require` and `assert`" /></p>

<h3><code>require</code> and <code>assert</code></h3>

<p><code>require</code> and <code>assert</code> both serve as executable documentation. Both are
useful for situations in which the type system cannot express the required
invariants. <code>assert</code> is used for <em>invariants</em> that the code assumes (either
internal or external), for example</p>

<pre><code>val stream = getClass.getResourceAsStream(&quot;someclassdata&quot;)
assert(stream != null)
</code></pre>

<p>Whereas <code>require</code> is used to express API contracts:</p>

<pre><code>def fib(n: Int) = {
  require(n &gt; 0)
  ...
}
</code></pre>

<p><a id="Functional programming" /></p>

<h2>Functional programming</h2>

<p><em>Value oriented</em> programming confers many advantages, especially when
used in conjunction with functional programming constructs. This style
emphasizes the transformation of values over stateful mutation,
yielding code that is referentially transparent, providing stronger
invariants and thus also easier to reason about. Case classes, pattern
matching, destructuring bindings, type inference, and lightweight
closure and method creation syntax are the tools of this trade.</p>

<p><a id="Functional programming-Case classes as algebraic data types" /></p>

<h3>Case classes as algebraic data types</h3>

<p>Case classes encode ADTs: they are useful for modelling a large number
of data structures and provide for succinct code with strong
invariants, especially when used in conjunction with pattern matching.
The pattern matcher implements exhaustivity analysis providing even
stronger static guarantees.</p>

<p>Use the following pattern when encoding ADTs with case classes:</p>

<pre><code>sealed trait Tree[T]
case class Node[T](left: Tree[T], right: Tree[T]) extends Tree[T]
case class Leaf[T](value: T) extends Tree[T]
</code></pre>

<p class="LP">the type <code>Tree[T]</code> has two constructors: <code>Node</code> and <code>Leaf</code>. Declaring the type <code>sealed</code> allows the compiler to do exhaustivity analysis since constructors cannot be added outside the source file.</p>

<p>Together with pattern matching, such modelling results in code that is
both succinct &ldquo;obviously correct&rdquo;:</p>

<pre><code>def findMin[T &lt;: Ordered[T]](tree: Tree[T]) = tree match {
  case Node(left, right) =&gt; Seq(findMin(left), findMin(right)).min
  case Leaf(value) =&gt; value
}
</code></pre>

<p>While recursive structures like trees constitute classic applications of
ADTs, their domain of usefulness is much larger. Disjoint unions in particular are
readily modelled with ADTs; these occur frequently in state machines.</p>

<p><a id="Functional programming-Options" /></p>

<h3>Options</h3>

<p>The <code>Option</code> type is a container that is either empty (<code>None</code>) or full
(<code>Some(value)</code>). They provide a safe alternative to the use of <code>null</code>,
and should be used in their stead whenever possible. They are a
collection (of at most one item) and they are embellished with
collection operations &mdash; use them!</p>

<p>Write</p>

<pre><code>var username: Option[String] = None
...
username = Some(&quot;foobar&quot;)
</code></pre>

<p class="LP">instead of</p>

<pre><code>var username: String = null
...
username = &quot;foobar&quot;
</code></pre>

<p class="LP">since the former is safer: the <code>Option</code> type statically enforces that <code>username</code> must be checked for emptyness.</p>

<p>Conditional execution on an <code>Option</code> value should be done with
<code>foreach</code>; instead of</p>

<pre><code>if (opt.isDefined)
  operate(opt.get)
</code></pre>

<p class="LP">write</p>

<pre><code>opt foreach { value =&gt;
  operate(value)
}
</code></pre>

<p>The style may seem odd, but provides greater safety (we don&rsquo;t call the
exceptional <code>get</code>) and brevity. If both branches are taken, use
pattern matching:</p>

<pre><code>opt match {
  case Some(value) =&gt; operate(value)
  case None =&gt; defaultAction()
}
</code></pre>

<p class="LP">but if all that's missing is a default value, use <code>getOrElse</code></p>

<pre><code>operate(opt getOrElse defaultValue)
</code></pre>

<p>Do not overuse <code>Option</code>: if there is a sensible
default &mdash; a <a href="http://en.wikipedia.org/wiki/Null_Object_pattern"><em>Null Object</em></a> &mdash; use that instead.</p>

<p><code>Option</code> also comes with a handy constructor for wrapping nullable values:</p>

<pre><code>Option(getClass.getResourceAsStream(&quot;foo&quot;))
</code></pre>

<p class="LP">is an <code>Option[InputStream]</code> that assumes a value of <code>None</code> should <code>getResourceAsStream</code> return <code>null</code>.</p>

<p><a id="Functional programming-Pattern matching" /></p>

<h3>Pattern matching</h3>

<p>Pattern matches (<code>x match { ...</code>) are pervasive in well written Scala
code: they conflate conditional execution, destructuring, and casting
into one construct. Used well they enhance both clarity and safety.</p>

<p>Use pattern matching to implement type switches:</p>

<pre><code>obj match {
  case str: String =&gt; ...
  case addr: SocketAddress =&gt; ...
</code></pre>

<p>Pattern matching works best when also combined with destructuring (for
example if you are matching case classes); instead of</p>

<pre><code>animal match {
  case dog: Dog =&gt; &quot;dog (%s)&quot;.format(dog.breed)
  case _ =&gt; animal.species
  }
</code></pre>

<p class="LP">write</p>

<pre><code>animal match {
  case Dog(breed) =&gt; &quot;dog (%s)&quot;.format(breed)
  case other =&gt; other.species
}
</code></pre>

<p>Write <a href="http://www.scala-lang.org/node/112">custom extractors</a> but only with
a dual constructor (<code>apply</code>), otherwise their use may be out of place.</p>

<p>Don&rsquo;t use pattern matching for conditional execution when defaults
make more sense. The collections libraries usually provide methods
that return <code>Option</code>s; avoid</p>

<pre><code>val x = list match {
  case head :: _ =&gt; head
  case Nil =&gt; default
}
</code></pre>

<p class="LP">because</p>

<pre><code>val x = list.headOption getOrElse default
</code></pre>

<p class="LP">is both shorter and communicates purpose.</p>

<p><a id="Functional programming-Partial functions" /></p>

<h3>Partial functions</h3>

<p>Scala provides syntactical shorthand for defining a <code>PartialFunction</code>:</p>

<pre><code>val pf: PartialFunction[Int, String] = {
  case i if i%2 == 0 =&gt; &quot;even&quot;
}
</code></pre>

<p class="LP">and they may be composed with <code>orElse</code></p>

<pre><code>val tf: (Int =&gt; String) = pf orElse { case _ =&gt; &quot;odd&quot;}

tf(1) == &quot;odd&quot;
tf(2) == &quot;even&quot;
</code></pre>

<p>Partial functions arise in many situations and are effectively
encoded with <code>PartialFunction</code>, for example as arguments to
methods</p>

<pre><code>trait Publisher[T] {
  def subscribe(f: PartialFunction[T, Unit])
}

val publisher: Publisher[Int] = ..
publisher.subscribe {
  case i if isPrime(i) =&gt; println(&quot;found prime&quot;, i)
  case i if i%2 == 0 =&gt; count += 2
  /* ignore the rest */
}
</code></pre>

<p class="LP">or in situations that might otherwise call for returning an <code>Option</code>:</p>

<pre><code>// Attempt to classify the the throwable for logging.
type Classifier = Throwable =&gt; Option[java.util.logging.Level]
</code></pre>

<p class="LP">might be better expressed with a <code>PartialFunction</code></p>

<pre><code>type Classifier = PartialFunction[Throwable, java.util.Logging.Level]
</code></pre>

<p class="LP">as it affords greater composability:</p>

<pre><code>val classifier1: Classifier
val classifier2: Classifier

val classifier = classifier1 orElse classifier2 orElse { _ =&gt; java.util.Logging.Level.FINEST }
</code></pre>

<p><a id="Functional programming-Destructuring bindings" /></p>

<h3>Destructuring bindings</h3>

<p>Destructuring value bindings are related to pattern matching; they use the same
mechanism but are applicable when there is exactly one option (lest you accept
the possibility of an exception). Destructuring binds are particularly useful for
tuples and case classes.</p>

<pre><code>val tuple = ('a', 1)
val (char, digit) = tuple

val tweet = Tweet(&quot;just tweeting&quot;, Time.now)
val Tweet(text, timestamp) = tweet
</code></pre>

<p><a id="Functional programming-Lazyness" /></p>

<h3>Lazyness</h3>

<p>Fields in scala are computed <em>by need</em> when <code>val</code> is prefixed with
<code>lazy</code>. Because fields and methods are equivalent in Scala (lest the fields
are <code>private[this]</code>)</p>

<pre><code>lazy val field = computation()
</code></pre>

<p class="LP">is (roughly) short-hand for</p>

<pre><code>var _theField = None
def field = if (_theField.isDefined) _theField.get else {
  _theField = Some(computation())
  _theField.get
}
</code></pre>

<p class="LP">i.e., it computes a results and memoizes it. Use lazy fields for this purpose, but avoid using lazyness when lazyness is required by semantics. In these cases it's better to be explicit since it makes the cost model explicit, and side effects can be controlled more precisely.</p>

<p>Lazy fields are thread safe.</p>

<p><a id="Functional programming-Call by name" /></p>

<h3>Call by name</h3>

<p>Method parameters may be specified by-name, meaning the parameter is
bound not to a value but to a <em>computation</em> that may be repeated. This
feature must be applied with care; a caller expecting by-value
semantics will be surprised. The motivation for this feature is to
construct syntactically natural DSLs &mdash; new control constructs in
particular can be made to look much like native language features.</p>

<p>Only use call-by-name for such control constructs, where it is obvious
to the caller that what is being passed in is a &ldquo;block&rdquo; rather than
the result of an unsuspecting computation. Only use call-by-name arguments
in the last position of the last argument list. When using call-by-name,
ensure that method is named so that it is obvious to the caller that
its argument is call-by-name.</p>

<p>When you do want a value to be computed multiple times, and especially
when this computation is side effecting, use explicit functions:</p>

<pre><code>class SSLConnector(mkEngine: () =&gt; SSLEngine)
</code></pre>

<p class="LP">The intent remains obvious and caller is left without surprises.</p>

<p><a id="Functional programming-`flatMap`" /></p>

<h3><code>flatMap</code></h3>

<p><code>flatMap</code> &mdash; the combination of <code>map</code> with <code>flatten</code> &mdash; deserves special
attention, for it has subtle power and great utility. Like its brethren <code>map</code>, it is frequently
available in nontraditional collections such as <code>Future</code> and <code>Option</code>. Its behavior
is revealed by its signature; for some <code>Container[A]</code></p>

<pre><code>flatMap[B](f: A =&gt; Container[B]): Container[B]
</code></pre>

<p class="LP"><code>flatMap</code> invokes the function <code>f</code> for the element(s) of the collection producing a <em>new</em> collection, (all of) which are flattened into its result. For example, to get all permutations of two character strings that aren't the same character repeated twice:</p>

<pre><code>val chars = 'a' to 'z'
val perms = chars flatMap { a =&gt; 
  chars flatMap { b =&gt; 
    if (a != b) Seq(&quot;%c%c&quot;.format(a, b)) 
    else Seq() 
  }
}
</code></pre>

<p class="LP">which is equivalent to the more concise for-comprehension (which is &mdash; roughly &mdash; syntactical sugar for the above):</p>

<pre><code>val perms = for {
  a &lt;- chars
  b &lt;- chars
  if a != b
} yield &quot;%c%c&quot;.format(a, b)
</code></pre>

<p><code>flatMap</code> is frequently useful when dealing with <code>Options</code> &mdash; it will
collapse chains of options down to one,</p>

<pre><code>val host: Option[String] = ..
val port: Option[Int] = ..

val addr: Option[InetSocketAddress] =
  host flatMap { h =&gt;
    port map { p =&gt;
      new InetSocketAddress(h, p)
    }
  }
</code></pre>

<p class="LP">which is also made more succinct with <code>for</code></p>

<pre><code>val addr: Option[InetSocketAddress] = for {
  h &lt;- host
  p &lt;- port
} yield new InetSocketAddress(h, p)
</code></pre>

<p>The use of <code>flatMap</code> in <code>Future</code>s is discussed in the
<a href="#Twitter's%20standard%20libraries-Futures">futures section</a>.</p>

<p><a id="Object oriented programming" /></p>

<h2>Object oriented programming</h2>

<p>Much of Scala&rsquo;s vastness lie in its object system. Scala is a <em>pure</em>
language in the sense that <em>all values</em> are objects; there is no
distinction between primitive types and composite ones.
Scala also features mixins allowing for more orthogonal and piecemeal
construction of modules that can be flexibly put together at compile
time with all the benefits of static type checking.</p>

<p>A motivation behind the mixin system was to obviate the need for
traditional dependency injection. The culmination of this &ldquo;component
style&rdquo; of programming is <a href="http://jboner.github.com/2008/10/06/real-world-scala-dependency-injection-di.html">the cake
pattern</a>.</p>

<p><a id="Object oriented programming-Dependency injection" /></p>

<h3>Dependency injection</h3>

<p>In our use, however, we&rsquo;ve found that Scala itself removes so much of
the syntactical overhead of &ldquo;classic&rdquo; (constructor) dependency
injection that we&rsquo;d rather just use that: it is clearer, the
dependencies are still encoded in the (constructor) type, and class
construction is so syntactically trivial that it becomes a breeze.
It&rsquo;s boring and simple and it works. <em>Use dependency injection for
program modularization</em>, and in particular, <em>prefer composition over
inheritance</em> &mdash; for this leads to more modular and testable programs.
When encountering a situation requiring inheritance, ask yourself: how
you structure the program if the language lacked support for
inheritance? The answer may be compelling.</p>

<p>Dependency injection typically makes use of traits,</p>

<pre><code>trait TweetStream {
  def subscribe(f: Tweet =&gt; Unit)
}
class HosebirdStream extends TweetStream ...
class FileStream extends TweetStream ..

class TweetCounter(stream: TweetStream) {
  stream.subscribe { tweet =&gt; count += 1 }
}
</code></pre>

<p>It is common to inject <em>factories</em> &mdash; objects that produce other
objects. In these cases, favor the use of simple functions over specialized
factory types.</p>

<pre><code>class FilteredTweetCounter(mkStream: Filter =&gt; TweetStream) {
  mkStream(PublicTweets).subscribe { tweet =&gt; publicCount += 1 }
  mkStream(DMs).subscribe { tweet =&gt; dmCount += 1 }
}
</code></pre>

<p><a id="Object oriented programming-Traits" /></p>

<h3>Traits</h3>

<p>Dependency injection does not at all preclude the use of common <em>interfaces</em>, or
the implemention of common code in traits. Quite contrary&mdash; the use of traits are
highly encouraged for exactly this reason: multiple interfaces
(traits) may be implemented by a concrete class, and common code can
be reused across all such classes.</p>

<p>Keep traits short and orthogonal: don&rsquo;t lump separable functionality
into a trait, think of the smallest related ideas that fit together. For example,
imagine you have an something that can do IO:</p>

<pre><code>trait IOer {
  def write(bytes: Array[Byte])
  def read(n: Int): Array[Byte]
}
</code></pre>

<p class="LP">separate the two behaviors:</p>

<pre><code>trait Reader {
  def read(n: Int): Array[Byte]
}
trait Writer {
  def write(bytes: Array[Byte])
}
</code></pre>

<p class="LP">and mix them together to form what was an <code>IOer</code>: <code>new Reader with Writer</code>&hellip; Interface minimalism leads to greater orthogonality and cleaner modularization.</p>

<p><a id="Object oriented programming-Visibility" /></p>

<h3>Visibility</h3>

<p>Scala has very expressive visibility modifiers. It&rsquo;s important to use
these as they define what constitutes the <em>public API</em>. Public APIs
should be limited so users don&rsquo;t inadvertently rely on implementation
details and limit the author&rsquo;s ability to change them: They are crucial
to good modularity. As a rule, it&rsquo;s much easier to expand public APIs
than to contract them. Poor annotations can also compromise backwards
binary compatibility of your code.</p>

<h4><code>private[this]</code></h4>

<p>A class member marked <code>private</code>, </p>

<pre><code>private val x: Int = ...
</code></pre>

<p class="LP">is visible to all <em>instances</em> of that class (but not their subclasses). In most cases, you want <code>private[this]</code>.</p>

<pre><code>private[this] val: Int = ..
</code></pre>

<p class="LP">which limits visibilty to the particular instance. The Scala compiler is also able to translate <code>private[this]</code> into a simple field access (since access is limited to the statically defined class) which can sometimes aid performance optimizations.</p>

<h4>Singleton class types</h4>

<p>It&rsquo;s common in Scala to create singleton class types, for example</p>

<pre><code>def foo() = new Foo with Bar with Baz {
  ...
}
</code></pre>

<p class="LP">In these situations, visibility can be constrained by declaring the returned type:</p>

<pre><code>def foo(): Foo with Bar = new Foo with Bar with Baz {
  ...
}
</code></pre>

<p class="LP">where callers of <code>foo()</code> will see a restricted view (<code>Foo with Bar</code>) of the returned instance.</p>

<p><a id="Object oriented programming-Structural typing" /></p>

<h3>Structural typing</h3>

<p>Do not use structural types in normal use. They are a convenient and
powerful feature, but unfortunately do not have an efficient
implementation on the JVM. However &mdash; due to an implemenation quirk &mdash;
they provide a very nice shorthand for doing reflection.</p>

<pre><code>val obj: AnyRef
obj.asInstanceOf[{def close()}].close()
</code></pre>

<p><a id="Garbage collection" /></p>

<h2>Garbage collection</h2>

<p>We spend a lot of time tuning garbage collection in production. The
garbage collection concerns are largely similar to those of Java
though idiomatic Scala code tends to generate more (short-lived)
garbage than idiomatic Java code &mdash; a byproduct of the functional
style. Hotspot&rsquo;s generational garbage collection typically makes this
a nonissue as short lived garbage effectively free in most circumstances</p>

<p>Before tackling GC performance issues, watch
<a href="http://www.infoq.com/presentations/JVM-Performance-Tuning-twitter">this</a>
presentation by Attila that illustrates some of our experiences with
GC tuning.</p>

<p>In Scala proper, your only tool to mitigate GC problems is to generate
less garbage; but do not act without data! Unless you are doing
something obviously degenerate, use the various Java profiling tools
&mdash; our own include
<a href="https://github.com/mariusaeriksen/heapster">heapster</a> and
<a href="https://github.com/twitter/jvmgcprof">gcprof</a>.</p>

<p><a id="Java compatibility" /></p>

<h2>Java compatibility</h2>

<p>When we write code in Scala that is used from Java, we ensure
that usage from Java remains idiomatic. Oftentimes this requires
no extra effort &mdash; classes and pure traits are exactly equivalent
to their Java counterpart &mdash; but sometimes separate Java APIs
need to be provided. A good way to get a feel for your library&rsquo;s Java
API is to write a unittest in Java (just for compilation); this also ensures
that the Java-view of your library remains stable over time as the Scala
compiler can be volatile in this regard.</p>

<p>Traits that contain implementation are not directly
usable from Java: extend an abstract class with the trait
instead.</p>

<pre><code>// Not directly usable from Java
trait Animal {
  def eat(other: Animal)
  def eatMany(animals: Seq[Animal) = animals foreach(eat(_))
}

// But this is:
abstract class JavaAnimal extends Animal
</code></pre>

<p><a id="Twitter's standard libraries" /></p>

<h2>Twitter&rsquo;s standard libraries</h2>

<p>The most important standard libraries at Twitter are
<a href="http://github.com/twitter/util">Util</a> and
<a href="https://github.com/twitter/finagle">Finagle</a>. Util should be
considered an extension to the Scala and Java standard libraries,
providing missing functionality or more appropriate implementations. Finagle
is our RPC system; the kernel distributed systems components.</p>

<p><a id="Twitter's standard libraries-Futures" /></p>

<h3>Futures</h3>

<p>Futures have been <a href="#Concurrency-Futures">discussed</a>
briefly in the <a href="#Concurrency">concurrency section</a>. They
are the central mechanism for coordination asynchronous
processes and are pervasive in our codebase and core to Finagle.
Futures allow for the composition of concurrent events, and simplifies
reasoning about highly concurrent operations. They also lend themselves
to a highly efficient implementation on the JVM.</p>

<p>Twitter&rsquo;s futures are <em>asynchronous</em>, so blocking operations &mdash;
basically any operation that can suspend the execution of its thread;
network IO and disk IO are examples &mdash; must be handled by a system
that itself provides futures for the results of said operations.
Finagle provides such a system for network IO.</p>

<p>Futures are plain and simple: they hold the <em>promise</em> for the result
of a computation that is not yet complete. They are a simple container
&mdash; a placeholder. A computation could fail of course, and this must
also be encoded: a Future can be in exactly one of 3 states: <em>pending</em>,
<em>failed</em> or <em>completed</em>.</p>

<div class="explainer">
<h3>Aside: <em>Composition</em></h3>
<p>Let's revisit what we mean by composition: combining simpler components
into more complicated ones. The canonical example of this is function
composition: Given functions <em>f</em> and
<em>g</em>, the composite function <em>(g&#8728;f)(x) = g(f(x))</em> &mdash; the result
of applying <em>x</em> to <em>f</em> first, and then the result of that
to <em>g</em> &mdash; can be written in Scala:</p>

<pre><code>val f = (i: Int) => i.toString
val g = (s: String) => s+s+s
val h = g compose f  // : Int => String
    
scala> h(123)
res0: java.lang.String = 123123123</code></pre>

<p class="LP">the function <em>h</em> being the composite. It is a <em>new</em> function that combines both <em>f</em> and <em>g</em> in a predefined way.</p>
</div>

<p>Futures are a type of collection &mdash; they are a container of
either 0 or 1 elements &mdash; and you&rsquo;ll find they have standard
collection methods (eg. <code>map</code>, <code>filter</code>, and <code>foreach</code>). Since a Future&rsquo;s
value is deferred, the result of applying any of these methods
is necessarily also deferred; in</p>

<pre><code>val result: Future[Int]
val resultStr: Future[String] = result map { i =&gt; i.toString }
</code></pre>

<p class="LP">the function <code>{ i => i.toString }</code> is not invoked until the integer value becomes available, and the transformed collection <code>resultStr</code> is also in pending state until that time.</p>

<p>Lists can be flattened;</p>

<pre><code>val listOfList: List[List[Int]] = ..
val list: List[Int] = listOfList.flatten
</code></pre>

<p class="LP">and this makes sense for futures, too:</p>

<pre><code>val futureOfFuture: Future[Future[Int]] = ..
val future: Future[Int] = futureOfFuture.flatten
</code></pre>

<p class="LP">since futures are deferred, the implementation of <code>flatten</code> &mdash; it returns immediately &mdash; has to return a future that is the result of waiting for the completion of the outer future (<code><b>Future[</b>Future[Int]<b>]</b></code>) and after that the inner one (<code>Future[<b>Future[Int]</b>]</code>). If the outer future fails, the flattened future must also fail.</p>

<p>Futures (like Lists) also define <code>flatMap</code>; <code>Future[A]</code> defines its signature as</p>

<pre><code>flatMap[B](f: A =&gt; Future[B]): Future[B]
</code></pre>

<p class="LP">which is like the combination of both <code>map</code> and <code>flatten</code>, and we could implement it that way:</p>

<pre><code>def flatMap[B](f: A =&gt; Future[B]): Future[B] = {
  val mapped: Future[Future[B]] = this map f
  val flattened: Future[B] = mapped.flatten
  flattened
}
</code></pre>

<p>This is a powerful combination! With <code>flatMap</code> we can define a Future that
is the result of two futures sequenced, the second future computed based
on the result of the first one. Imagine we needed to do two RPCs in order
to authenticate a user (id), we could define the composite operation in the
following way:</p>

<pre><code>def getUser(id: Int): Future[User]
def authenticate(user: User): Future[Boolean]

def isIdAuthed(id: Int): Future[Boolean] = 
  getUser(id) flatMap { user =&gt; authenticate(user) }
</code></pre>

<p class="LP">an additional benefit to this type of composition is that error handling is built-in: the future returned from <code>isAuthed(..)</code> will fail if either of <code>getUser(..)</code> or <code>authenticate(..)</code> does with no extra error handling code.</p>

<h4>Style</h4>

<p>Future callback methods (<code>respond</code>, <code>onSuccess',</code>onFailure<code>,</code>ensure`)
return a new future that is <em>chained</em> to its parent. This future is guaranteed
to be completed only after its parent, enabling patterns like</p>

<pre><code>acquireResource()
future onSuccess { value =&gt;
  computeSomething(value)
} ensure {
  freeResource()
}
</code></pre>

<p class="LP">where <code>freeResource()</code> is guaranteed to be executed only after <code>computeSomething</code>, allowing for emulation of the native <code>try .. finally</code> pattern.</p>

<p>Use <code>onSuccess</code> instead of <code>foreach</code> &mdash; it is symmetrical to <code>onFailure</code> and
is a better name for the purpose, and also allows for chaining.</p>

<p>Always try to avoid creating your own <code>Promise</code>s: nearly every task
can be accomplished via the use of predefined combinators. These
combinators ensure errors and cancellations are propagated, and generally
encourage <em>dataflow style</em> programming which usually <a
href="#Concurrency-Futures">obviates the need for synchronization and
volatility declarations</a>.</p>

<p>Code written in tail-recursive style are not subject so space leaks,
allowing for efficient implementation of loops in dataflow-style:</p>

<pre><code>case class Node(parent: Option[Node], ...)
def getNode(id: Int): Future[Node] = ...

def getHierarchy(id: Int, nodes: List[Node] = Nil): Future[Node] =
  getNode(id) flatMap {
    case n@Node(Some(parent), ..) =&gt; getHierarchy(parent, n :: nodes)
    case n =&gt; Future.value((n :: nodes).reverse)
  }
</code></pre>

<p><code>Future</code> defines many useful methods: Use <code>Future.value()</code> and
<code>Future.exception()</code> to create pre-satisfied futures.
<code>Future.collect()</code>, <code>Future.join()</code> and <code>Future.select()</code> provide
combinators that turn many futures into one (ie. the gather part of a
scatter-gather operation).</p>

<h4>Cancellation</h4>

<p>Futures implement a weak form of cancellation. Invoking <code>Future#cancel</code>
does not directly terminate the computation but instead propagates a
level triggered <em>signal</em> that may be queried by whichever process
ultimately satisfies the future. Cancellation flows in the opposite
direction from values: a cancellation signal set by a consumer is
propagated to its producer. The producer uses <code>onCancellation</code> on
<code>Promise</code> to listen to this signal and act accordingly.</p>

<p>This means that the cancellation semantics depend on the producer,
and there is no default implementation. <em>Cancellation is a but a hint</em>.</p>

<h4>Locals</h4>

<p>Util&rsquo;s
<a href="https://github.com/twitter/util/blob/master/util-core/src/main/scala/com/twitter/util/Local.scala#L40"><code>Local</code></a>
provides a reference cell that is local to a particular future dispatch tree. Setting the value of a local makes this
value available to any computation deferred by a Future in the same thread. They are analagous to thread locals,
except their scope is not a Java thread but a tree of &ldquo;future threads&rdquo;. In</p>

<pre><code>trait User {
  def name: String
  def incrCost(points: Int)
}
val user = new Local[User]

...

user() = currentUser
rpc() ensure {
  user().incrCost(10)
}
</code></pre>

<p class="LP"><code>user()</code> in the <code>ensure</code> block will refer to the value of the <code>user</code> local at the time the callback was added.</p>

<p>As with thread locals, <code>Local</code>s can be very convenient, but should
almost always be avoided: make sure the problem cannot be sufficiently
solved by passing data around explicitly, even if it is somewhat
burdensome.</p>

<p>Locals are used effectively by core libraries for <em>very</em> common
concerns &mdash; threading through RPC traces, propagating monitors,
creating &ldquo;stack traces&rdquo; for future callbacks &mdash; where any other solution
would unduly burden the user. Locals are inappropriate in almost any
other situation.</p>

<!--
  ### Offer/Broker

-->

<p><a id="Acknowledgments" /></p>

<h2>Acknowledgments</h2>

<p>The lessons herein are those of Twitter&rsquo;s Scala community &mdash; I hope
I&rsquo;ve been a faithful chronicler.</p>

<p>Blake Matheny, Nick Kallen, and Steve Gury provided much helpful
guidance and many excellent suggestions.</p>

<hr/>
<ol id="notes">

<li id="fn1">
<a href="http://yourkit.com">Yourkit</a>は良いプロファイラだ。 <a href="#fnref1" title="Jump back to reference">[back]</a></li>
<li id="fn2">
From <a href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/loadbalancer/Heap.scala#L41">Finagle&rsquo;s heap
balancer</a> <a href="#fnref2" title="Jump back to reference">[back]</a></li>
</ol>

<center class="footer">
Copyright &copy; 2012 Twitter Inc.<br>
Licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>
<!--
<a href="http://creativecommons.org/licenses/by/3.0/"><img style="bottom: 0; right: 0; border: 0;" src="http://i.creativecommons.org/l/by/3.0/80x15.png" /></a>
-->
</center>

</body>
</html>
